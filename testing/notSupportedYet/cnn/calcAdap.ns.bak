# Anzahl der Fenster von comandLine lesen:
#double windows;
#windows = comandLineDouble(1);

# Schleifenzähler
int q;
for (q=1; q < 2; q = q+1)
{
    #### Feedforward berechnen: ####
    network n;
    n.cnnNeutral<couplingSumNode,stdEdgeOrd3> (64, 64, "Params/paramFF.txt");
    dynNode_dt = 1;
    
    #Data einlesen
    n.readInitialCondition (couplingSumNode, "Data/input1.txt");

    
#	n.printNodeStatistics();
    # erste Integration wegwerfen

#    n.simulate(1);

    # zweiter Zeitschritt = Summe über Nachbarn = feedforward
    n.observeAll( "temp/feedforward1.txt" );
#n.simulate(1);
	n.evolve(0.0,1.0);
	
	n.snapshot();
 #   n.simulate(1);
    n.removeObserver();
    n.clear();
    
   
   #### CNN berechnen: #####
    
    n.cnnNeutral<cnnNode,sigEdgeOrd3> (64,64,"Params/paramFB.txt");
    n.readInitialCondition( cnnNode , "Data/state1.txt");
    dynNode_dt=0.2;
	n.readParams("cnnNode_ff", "temp/feedforward1.txt");
	n.readParams("cnnNode_bias", "Params/bias.txt");

    # Alle Zeitschritte rauschreiben:
#	m.observeTime("output/results_adap.txt");



#	n.printNodeStatistics();
	n.observeAll<sigEdge>("output/results_adap.txt");
#	n.printNodeStatistics();
    #dynNetwork_ioNodeDt = 0.2; 
        dynNetwork_ioNodeDt = 40.0; 

	n.evolve(0.0,40);
	
	### Ergebnisse nach 200 Schritten ausgeben:
    # Separate Ausgabe:
	#m.observeAll<sigEdge>("output/output".q.".txt");
    
	# kombinierte Ausgabe:
#	m.observeAll<sigEdge>("output/results.txt");
    #streamOutNode_append = 1;
    #streamOutNode_compress = 1;
    
	#m.snapshot();	
	# Aufräumen
	n.removeObserver();
    n.clear();
};
